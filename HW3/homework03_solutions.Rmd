---
title: "Stat 133 HW03: Flow Control Structures and Functions with R"
author: "Gaston Sanchez"
output: pdf_document
---

## Introduction

This assignment has two purposes:

a) to familiarize you with control flow structures in R 
b) to introduce you to writing functions in R

Submit your assignment to bcourses, specifically turn in your __Rmd__ (R markdown) file as well as the produced pdf file. Make sure to change the argument ```eval=TRUE``` inside every testing code chunk.

-----

## Last Element

Write a function ```last()``` that takes a vector (or factor) and returns the last element in the vector. 
```{r}
last <- function(x) {
  x[length(x)]
}
```

For instance:
```{r}
last(c('A', 'E', 'I', 'O', 'U'))
last(c(2, 4, 6, 8, 10))
```


-----

## If-then-else

Write a function ```multfive()``` that takes a number and determines whether the number is multiple of 5. If the provided number is multiple of five, then the output must be: ```it is multiple of five```. Conversely, if the provided number is not a multiple of five, then the output must be: ```it's not a multiple of 5```. 
```{r}
multfive <- function(x) {
  if(x %% 5 == 0) {
    print('it is multiple of 5')
  } else {
    print("it's not a multiple of 5")
  }
}
```

For example:
```{r}
# multiple of five
multfive(10)

# not a multiple of five
multfive(33)
```


-----

## Create your histogram plotting function

Write a function ```histogram()``` that plots a histogram with added vertical lines for the following summary statistics: minimum value, median, mean, and maximum value. The main idea is to wrap the high-level function ```hist()``` and then plot the lines with a low-level plotting function.

Define your function with the following requirements: 

- bars of histogram colored in "gray90""
- line of minimum value in color "gray30", and dashed type
- line of maximum value in color "gray30", and dashed type
- line of median value in color "orange"
- line of mean value in color "tomato"
- all lines (min, max, median, mean) with a width of 3
```{r}
histogram <- function(x, ...) {
  exam_sum <- c(
    min(x),
    max(x),
    median(x),
    mean(x)
  )
  hist(x, col = 'gray90', ...)
  abline(v = exam_sum, 
         col = c('gray30', 'gray30', 'orange', 'tomato'),
         lwd = 3, lty = c(2, 2, 1, 1))
}
```

For instance:
```{r, fig.width=5, fig.height=4}
histogram(mtcars$mpg)
```


-----

## Converting Fahrenheit Degrees

The table below shows the different formulas for converting Fahrenheit degrees into other scales:

| Units   | from Fahrenheit     |
| ------- | ------------------- |
| Celsius | (째F - 32) x 5/9     |
| Kelvin  | (째F + 459.67) x 5/9 |
| Reaumur | (째F - 32) x 4/9     |
| Rankine | 째F + 459.67         |

Write a function that converts from Fahrenheit degrees into each type of the four alternative scales. This implies writing four different functions:

- ```to_celsius()```
- ```to_kelvin()```
- ```to_reaumur()```
- ```to_rankine()```

```{r}
to_celsius <- function(x) {
  (x - 32) * (5/9)
}

to_kelvin <- function(x) {
  (x + 459.67) * (5/9)
}

to_reaumur <- function(x) {
  (x - 32) * (4/9)
}

to_rankine <- function(x) {
  x + 459.67
}
```

For example: 
```{r}
to_celsius(34)
to_kelvin(34)
to_reaumur(34)
to_rankine(34)
```

-----

## Using switch()

Create a function ```convert()``` that converts Fahrenheit degrees into the specified scale. Use ```switch()``` and the previously defined functions---```to_celsius()```, ```to_kelvin()```, ```to_reaumur()``` and ```to_rankine()```---to define ```convert()```. Use two arguments: ```x``` and ```to```, like this:
```{r, eval=FALSE}
convert(40, to = "celsius")
```

By default, ```to = "celsius"```, but it can take values such as ```"kelvin"```, ```"reaumur"```, or ```"rankine"```
```{r}
convert <- function(x, to = "celsius") {
  switch(to,
         "celsius" = to_celsius(x),
         "kelvin" = to_kelvin(x),
         "reaumur" = to_reaumur(x),
         "rankine" = to_rankine(x))
}
```

For instance:
```{r}
convert(32, "celsius")
convert(32, "kelvin")
convert(32, "reaumur")
convert(32, "rankine")
```


-----

## Permutations

The possible number of combinations of $k$ objects from a set of $n$ objects is given by the formula:
$$
nCk = \frac{n!}{k! (n-k)!}
$$
where $n!$ is the factorial of a number $n$, i.e. $n! = n (n-1) (n - 2) ... (2) (1)$. For instance, the number of combinations of 2 objects from a set of 4 objects is:
$$
{4\choose 2} = \frac{4!}{2! (4-2)!} = 6
$$

R provides the functions ```factorial()``` to compute the factorial of a number: 
```{r}
factorial(4)
```

R also provides the function ```choose()``` that computes the number of combinations:
```{r}
# combinations of 2 objects from a set of 4
choose(4, 2)
```

R, however, does not have a function to compute permutations: 
$$
{_n P_k} = \frac{n!}{(n-k)!}
$$

```{r}
permute <- function(n, k) {
  if (n < 0 | k < 0) {
    stop('n and/or k cannot be negative')
  }
  if (n < k) {
    return(0)
  }
  n <- as.integer(n)
  k <- as.integer(k)
  factorial(n) / factorial(n-k)
}
```

Write a function ```permute()``` that calculates the number of permutations of $k$ objects from a set of $n$ objects. For instance:
```{r}
permute(6, 2)
```

Make sure that the function checks that both $n$ are $k$ are non-negative numbers (if any of them is negative, the function must stop). Also make sure that if $n$ is less than $k$, the result is zero. In addition, $n$ and $k$ should be coerced as integers.
```{r, eval=FALSE}
# the following calls should not work
permute(2, 6)
permute(-6, 6)
```


-----

## Average function with for loop

R provides the function ```mean()``` to calculate the arithmetic mean (i.e. average) of a numeric object. Create a function ```average()``` using a ___for loop___ to compute the mean. ```average()``` takes a numeric vector and returns the average.
$$
\bar{x} = \frac{1}{n} \sum^{n}_{i = 1} x_i
$$
```{r}
average <- function(x) {
  total <- length(x)
  x_sum <- 0
  for (i in seq_along(x)) {
    x_sum <- x_sum + x[i]
  }
  x_sum / total
}
```

For instance:
```{r}
average(1:5)
mean(1:5)
```

__Note:__ Remember that all arithmetic and math functions, as well as logical comparisons, are vectorized. This example with the ```average()``` function is just for practicing using control-flow structures.


-----

## Geometric Mean function

The formula of the geometric mean is:

$$
\left( \prod^{n}_{i = 1} x_i \right)^{1/n}
$$

Write a function ```geomean()``` that computes the geometric mean of a vector of positive numbers, using a ___for loop___:
```{r}
geomean <- function(x) {
  total <- length(x)
  x_prod <- 1
  for (i in seq_along(x)) {
    x_prod <- x_prod * x[i]
  }
  (x_prod)^(1/total)
}
```

For instance:
```{r}
geomean(1)
geomean(1:5)
```

___Note:___ Again, keep in mind that this example is for practicing purposes. In R, when performing a computation that involves iterating through the elements of a vector, a for loop might not be the best option. Instead of using a for loop, you can use the function ```prod()``` which is already vectorized. Here's how:
```{r}
gmean <- function(x) {
  prod(x)^(1 / length(x))
}
```
```gmean()``` will be more efficient than any function we create using for loops:
```{r}
gmean(1)
gmean(1:5)
gmean(seq(-1, 1, length.out = 20))
```


-----

## Frequency Table

Write a function ```freq_table()``` that takes a factor and generates a frequency table with 5 columns: 

1) ```category```: the levels of the factor
2) ```count```: absolute frequency
3) ```prop```: relative frequency (use four decimal places)
4) ```cumcount```: cumulative absolute frequency
5) ```cumprop```: cumulative relative frequency (use four decimal places)

Make sure that the input is a factor (otherwise the function should stop). Likewise, the output should be in ```data.frame``` form.


```{r}
freq_table <- function(x) {
  # computes a table of frequencies
  if (!is.factor(x)) {
    stop('x must be a factor')
  }
  
  # frequencies
  total <- length(x)
  counts <- as.vector(table(x))
  props <- round(counts / total, 4)
  cum_counts <- cumsum(counts)
  cum_props <- cumsum(props)
  
  # output
  data.frame(
    category = levels(x),
    count = counts,
    prop = props,
    cumcount = cum_counts,
    cumprop = cum_props)
}
```

Here's an example of how the output should look like:
```{r}
# some factor
set.seed(13)
sizes <- factor(
  sample(c('small', 'medium', 'large'), size = 90, replace = TRUE)
)

# frequency table
freq_table(sizes)
```

-----

## Summary Statistics Table

Write a function ```stats()``` that takes a numeric vector and generates the following descriptive statistics: 

- ```min```: minimum value
- ```max```: maximum value
- ```range```: range (max - min)
- ```q1```: first quartile
- ```q3```: third quartile
- ```iqr```: inter-quartile range (q3 - q1)
- ```median```: median
- ```mean```: mean
- ```sd```: standard deviation
- ```NAs```: number of missing values ```NA```

The function ```stats()``` should include an argument ```na.rm``` ---that takes a logical value--- so it can handle potential missing values. The output must be a data.frame of one column.

```{r}
stats <- function(x, na.rm = FALSE) { 
  # descriptive statistics
  stats <- c(
    min = min(x, na.rm = na.rm),
    max = max(x, na.rm = na.rm),
    range = max(x, na.rm = na.rm) - min(x, na.rm = na.rm),
    q1 = quantile(x, probs = 0.25, names = FALSE, na.rm = na.rm),
    q3 = quantile(x, probs = 0.75, names = FALSE, na.rm = na.rm),
    iqr = IQR(x, na.rm = na.rm),
    median = median(x, na.rm = na.rm),
    mean = mean(x, na.rm = na.rm),
    sd = sd(x, na.rm = na.rm),
    NAs = sum(is.na(x))
  )
  # output as data.frame
  data.frame(stats)
}
```

For example:
```{r}
# no missing values
stats(1:10)
# missing values
stats(c(1:4, NA, 6:9, NA), na.rm = TRUE)
```


-----

## Frequency Table and Summary Statistics

Having created the functions ```freq_table()``` and ```stats()```, use them to write a function ```univarite()``` for producing summary statistics depending on the type of input. If the provided input is a numeric vector, then ```stats()``` should be called. In turn, if the provided input is a factor, then ```freq_table()``` should be called. If the input is not a numeric vector or a factor, then ```univariate()``` will print: ```"x must be either a numeric vector or a factor"```

```{r}
univariate <- function(x) {
  if (!is.factor(x)) {
    if (!is.vector(x) & !is.numeric(x)) {
      stop("x must be either a numeric vector or a factor")
    }
  }
  
  if (is.factor(x)) {
    return(freq_table(x))
  } else {
    return(stats(x))
  }
}
```

For instance:
```{r}
# factor input
univariate(sizes)

# numeric input
univariate(1:10)
```

This should not work:
```{r, eval=FALSE}
# this should cause an error
univariate(colors()[1:5])
```


